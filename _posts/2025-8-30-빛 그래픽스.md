---
key:
title: 'ADS와 하이라이팅등을 통해 그래픽스의 빛 구현'
excerpt: '그래픽스'
tags: [그래픽스]
---

## **기본 조명 모델 심층 분석: ADS부터 3대 조명 유형까지**

3D 그래픽스에서 사실적인 장면을 구현하기 위한 핵심은 빛을 어떻게 계산하고 표현하는지에 달려 있다. 본문에서는 모든 **지역 조명(Local Illumination)** 계산의 기초가 되는 ADS 모델의 수학적 원리를 상세히 다루고, 이를 바탕으로 가장 널리 사용되는 세 가지 기본 조명 유형의 특징과 구체적인 GLSL 구현 방법을 심층적으로 분석한다. (지역 조명 모델은 다른 물체로부터 반사되는 빛, 즉 전역 조명(Global Illumination)은 고려하지 않는다.)



### **1. 모든 조명의 기반(빛 자체를 다룸): ADS 조명 모델의 수학적 원리**



ADS 모델은 물체 표면이 빛과 상호작용하는 방식을 세 가지 요소로 나누어 근사하는 기법이다. 프래그먼트 셰이더는 이 세 가지 기여도를 각각 계산한 뒤 합산하여 각 픽셀의 최종 색상을 결정한다. 최종 색상은 `물체색상 * (주변광 + 난반사) + 정반사` 형태로 조합된다.

- **Ambient (주변광):** 다른 표면에서 반사된 빛이 은은하게 전체 장면에 영향을 미치는 간접광을 흉내 내는 단순한 근사법이다. 실제 광원과의 관계와 상관없이 장면에 전역적으로 적용되는 최소한의 빛으로, 보통 `빛의 색상 × 낮은 강도`로 계산된다.

  OpenGL Shading Language

  ```
  float ambientStrength = 0.1;
  vec3 ambient = ambientStrength * lightColor;
  ```

- **Diffuse (난반사):** 빛이 특정 표면에 부딪혔을 때 모든 방향으로 고르게 흩어지는 현상을 모델링한다. 표면의 밝기는 빛이 얼마나 정면으로 부딪히는지에 따라 결정된다. 이는 **표면의 법선 벡터(Normal Vector)**와 **광원 방향 벡터(Light Direction)** 사이의 각도를 통해 계산된다. 두 벡터 사이의 각도가 작을수록(즉, 빛이 표면을 정면으로 비출수록) 표면은 더 밝아진다. 이 관계는 두 벡터의 **내적(Dot Product)**을 사용하여 효과적으로 계산할 수 있다.

  OpenGL Shading Language

  ```
  // lightDir: 광원에서 프래그먼트로 향하는 정규화된 벡터
  // normal: 프래그먼트의 정규화된 법선 벡터
  float diff = max(dot(normal, lightDir), 0.0);
  vec3 diffuse = diff * lightColor;
  ```

  `max(..., 0.0)`은 두 벡터의 각도가 90도 이상일 때(즉, 표면의 뒷면을 비출 때) 내적 값이 음수가 되는 것을 방지하여, 빛이 표면을 뚫고 나오는 현상을 막는다.

- **Specular (정반사):** 빛이 매끄러운 표면에서 거울처럼 특정 방향으로 강하게 반사되는 현상을 모델링한다. 반짝이는 하이라이트를 만들어낸다. 이는 **시선 방향(View Direction)**과 **빛의 반사 방향(Reflection Direction)**이 얼마나 가까운지에 따라 결정된다. 일반적으로 블린-퐁(Blinn-Phong) 모델이 많이 사용되며, 이는 계산이 더 빠른 **중간 벡터(Halfway Vector)**를 사용한다.

  OpenGL Shading Language

  ```
  // viewDir: 카메라에서 프래그먼트로 향하는 정규화된 벡터
  // halfwayDir: lightDir와 viewDir의 중간 방향 벡터, 정규화됨
  float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);
  vec3 specular = spec * lightColor;
  ```

  `32.0`은 **반짝임 계수(Shininess exponent)**로, 이 값이 클수록 하이라이트가 더 작고 날카로워진다.



### **2. 주요 조명 유형 비교(빛의 위치, 방향 이러한 기하학적인 요소에 따라 달라짐)**



세 가지 기본 조명은 기하학적으로 광원의 위치, 방향, 감쇠(빛의 세기 감소) 여부에 따라 구분되며, 셰이더에 전달해야 하는 정보(Uniform 변수)도 달라진다.

| 특징              | 방향성 조명 (Directional) | 점 광원 (Point)                 | 스포트라이트 (Spotlight)                                |
| ----------------- | ------------------------- | ------------------------------- | ------------------------------------------------------- |
| **위치**          | 없음 (무한히 멀리 있음)   | 있음                            | 있음                                                    |
| **방향**          | **있음** (모든 빛이 평행) | 없음 (모든 방향으로 방사)       | **있음** (특정 방향으로 제한)                           |
| **거리 감쇠**     | 없음                      | **있음**                        | **있음**                                                |
| **원뿔 효과**     | 없음                      | 없음                            | **있음**                                                |
| **주요 Uniforms** | `vec3 lightDir`           | `vec3 lightPos`, `float Kl, Kq` | `vec3 lightPos`, `vec3 spotDir`, `float cutoff, Kl, Kq` |





### **3. 조명 유형별 상세 원리 및 GLSL 구현**





#### **3.1. 방향성 조명 (Directional Light)**



광원이 무한히 멀리 있다고 가정하여, 모든 광선이 동일한 방향에서 평행하게 들어온다고 모델링한다. `lightDir` 벡터 하나가 씬 전체의 광원 방향을 결정하며, 위치와 상관없이 모든 오브젝트에 동일하게 적용된다.

- **GLSL 구현:** `lightDir`는 보통 정규화된 상태의 `uniform vec3`로 프래그먼트 셰이더에 전달된다. ADS 계산 시 이 값을 직접 사용하면 된다.

  OpenGL Shading Language

  ```
  // uniform vec3 lightDir; (예: vec3(-0.2, -1.0, -0.3))
  // uniform vec3 lightColor;
  
  // 난반사 계산
  float diff = max(dot(normal, -lightDir), 0.0); // 방향성 조명은 방향이 '향하는 곳'이므로 반대로 계산
  // ...
  ```



#### **3.2. 점 광원 (Point Light / 위치성 조명)**



3D 씬 내의 특정 위치에서 모든 방향으로 빛을 방출한다. 거리에 따라 빛이 약해지는 **거리 감쇠(Distance Attenuation)**가 특징이다. 감쇠량은 보통 아래의 2차 방정식으로 계산된다. `attenuation = 1.0 / (Kc + Kl * distance + Kq * distance * distance)` (Kc: 상수 감쇠, Kl: 선형 감쇠, Kq: 2차 감쇠)

- **심화: 감쇠 계수 값:** 이 계수들은 조명이 도달하는 거리를 결정한다. Kc는 보통 1.0으로 고정하며, Kl과 Kq 값에 따라 조명의 유효 범위가 달라진다. (예: 50 유닛 거리까지 도달하는 조명을 원할 경우 Kl=0.09, Kq=0.032 값을 주로 사용)

- **GLSL 구현:** 프래그먼트 셰이더는 광원의 위치(`lightPos`)와 현재 프래그먼트의 위치(`fragPos`)를 알아야 한다. 이 두 벡터의 차이를 통해 `lightDir`와 `distance`를 계산하고, 최종 조명 값에 `attenuation`을 곱해준다.

  OpenGL Shading Language

  ```
  // uniform vec3 lightPos;
  // in vec3 fragPos;
  
  vec3 lightDir = normalize(lightPos - fragPos);
  float distance = length(lightPos - fragPos);
  float attenuation = 1.0 / (1.0 + 0.09 * distance + 0.032 * distance * distance);
  
  // ... ADS 계산 ...
  vec3 finalLight = (ambient + diffuse + specular) * attenuation;
  ```



#### **3.3. 스포트라이트 (Spotlight)**



점 광원의 특징(위치, 거리 감쇠)과 방향성 조명의 특징(방향)을 모두 가진다. 빛이 **원뿔(cone) 모양**으로 제한되는 것이 가장 큰 특징이다.

- **심화: 부드러운 가장자리 (Soft Edges):** 단순한 **차단 각도(Cutoff Angle)**만 사용하면 스포트라이트의 가장자리가 칼로 자른 듯 날카롭게 보인다. 이를 부드럽게 만들기 위해, 빛이 완전히 차단되는 **외부 차단 각도(Outer Cutoff Angle)**를 추가로 사용한다. 빛의 강도는 내부 차단 각도와 외부 차단 각도 사이에서 점진적으로 0이 되도록 보간(interpolate)한다. GLSL의 `smoothstep` 함수가 이 효과를 구현하는 데 매우 유용하다.

- **GLSL 구현:** 점 광원 계산을 기반으로, 프래그먼트가 원뿔 내부에 있는지 확인하는 로직이 추가된다. 이는 **스포트라이트 방향 벡터(`spotDir`)**와 **광원에서 프래그먼트로 향하는 벡터(`lightDir`)** 사이의 내적 값을 사용하여 계산한다.

  OpenGL Shading Language

  ```
  // uniform vec3 spotDir;
  // uniform float cutoff;       // 내부 원뿔 각도의 코사인 값 (예: cos(glm::radians(12.5f)))
  // uniform float outerCutoff;  // 외부 원뿔 각도의 코사인 값 (예: cos(glm::radians(15.0f)))
  
  vec3 lightDir = normalize(lightPos - fragPos);
  float theta = dot(lightDir, -spotDir); // spotDir은 스포트라이트가 '향하는' 방향
  
  // 원뿔 가장자리 감쇠 계산
  float epsilon = cutoff - outerCutoff;
  float intensity = clamp((theta - outerCutoff) / epsilon, 0.0, 1.0);
  // 'smoothstep'을 사용하면 더 부드러운 효과를 얻을 수 있다.
  // float intensity = smoothstep(outerCutoff, cutoff, theta);
  
  // ... ADS 계산 및 거리 감쇠 적용 ...
  vec3 finalLight = (ambient + diffuse + specular) * attenuation * intensity;
  ```
---
key:
title: 'openGL 바인딩과 데이터 흐름'
excerpt: '그래픽스'
tags: [그래픽스]
---

## OpenGL의 '바인딩'과 데이터 흐름: 컴퓨터 내부의 정확한 작동 방식



컴퓨터에서 프로그램을 실행할 때, CPU, RAM(메인 메모리), GPU(그래픽 처리 장치), VRAM(GPU 메모리)은 복잡하게 상호작용한다. OpenGL은 이들 사이의 통신을 위한 명령어 세트 역할을 수행한다.



### 2. OpenGL의 '바인딩(Binding)' 개념 상세 설명

OpenGL은 내부적으로 **'상태 머신(State Machine)'**이라는 개념으로 동작한다. 이는 마치 특정 기능들을 제어하는 복잡한 제어판과 유사하다. 어떤 명령을 내리면, 이 제어판의 특정 스위치가 켜지거나(상태 변경), 특정 슬롯에 무언가가 연결되는(바인딩) 방식으로 동작한다.

- **바인딩 포인트 (Binding Point) 또는 타겟 (Target):**
  - OpenGL 드라이버 내부 또는 GPU 하드웨어 내부에 존재하는 **특정 유형의 OpenGL 객체를 연결하기 위한 '전용 레지스터'**이다. 이 레지스터는 항상 현재 활성화된 객체의 고유 ID(정수 값)를 담고 있다.
  - **레지스터(Register)**는 CPU나 GPU 내부에 있는 아주 작고 빠른 임시 저장 공간으로, 프로세서가 연산을 수행할 때 필요한 데이터를 잠깐 보관하는 데 사용된다. 바인딩 포인트가 가리키는 대상 ID는 이런 내부 레지스터에 저장되는 값과 유사하게 동작하여, GPU가 빠르게 참조할 수 있도록 한다.
  - 예를 들어, `GL_ARRAY_BUFFER`는 "현재 활성화된 정점 데이터 버퍼"의 ID를 저장하는 바인딩 포인트이다.
- **OpenGL 객체 (Object):**
  - `glGenBuffers()`, `glGenVertexArrays()` 같은 OpenGL 함수를 호출하여 생성되는, 고유한 ID(정수 값)를 가진 데이터 또는 설정 덩어리이다. 이 객체들은 GPU 메모리(VRAM) 또는 GPU 내부의 특정 공간에 존재하며, 이 ID를 통해 식별된다.
  - `vbo[0]`는 정점 데이터가 담길 수 있는 VBO(Vertex Buffer Object) 객체이고, `vao[0]`는 정점 속성 설정들을 기억하는 VAO(Vertex Array Object) 객체이다.
- **바인딩 (Binding) 행위:**
  - `glBind~~~()` 형태의 OpenGL 함수를 호출하는 행위이다 (예: `glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);`).
  - 이 명령이 실행되면, OpenGL 드라이버는 해당 **바인딩 포인트 레지스터의 값**을 지정된 객체(예: `vbo[0]`)의 고유 ID로 **업데이트**한다. 이렇게 되면, 이후에 해당 바인딩 포인트를 대상으로 하는 모든 OpenGL 명령(예: `glBufferData()`, `glVertexAttribPointer()`)은 이 '새롭게 연결된' 객체에 대해 실행된다. 즉, OpenGL은 이제부터 `GL_ARRAY_BUFFER`에 대한 명령이 들어오면 `vbo[0]` 객체에 작업을 수행해야 한다는 것을 내부적으로 '기억'하게 된다.



### 3. 큐브 렌더링을 위한 CPU-GPU 데이터 흐름 상세 설명

이제 실제 `setupVertices()`와 `display()` 함수 내에서 OpenGL 명령들이 어떻게 흐르고 컴퓨터 내부에서 어떤 일들이 순차적으로 발생하는지 자세히 살펴본다.

```c++
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <string>
#include <iostream> // std::cerr 사용
#include <fstream>
#include <cmath>
#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include "utils.h" // utils.h가 utils::createShaderProgram을 포함하도록 가정

// using namespace std; // std::를 명시적으로 사용하는 것이 좋습니다.

#define numVAOs 1
#define numVBOs 2

// 전역 변수 선언
float cameraX, cameraY, cameraZ;
float cubeLocX, cubeLocY, cubeLocZ;
GLuint renderingProgram;
GLuint vao[numVAOs];
GLuint vbo[numVBOs];

// display() 함수에서 재할당을 피하기 위해 전역 변수로 선언
GLuint mvLoc, pLoc; // Uniform location ID는 init()에서 한 번만 가져오는 것이 효율적
int width, height;
float aspect;
glm::mat4 pMat, mMat, mvMat, vMat; // vMat도 전역 선언

void setupVertices(void) { // 36 vertices, 12 triangles, makes 2x2x2 cube placed at origin
    float vertexPositions[108] = {
     -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f,
     1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f,
     1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f,
     1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f,
     1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f,
     -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,
     -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f,
     -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f,
     -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f,
     1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f,
     -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f,
     1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f
    };
    glGenVertexArrays(1, vao); // VAO 생성
    glBindVertexArray(vao[0]); // VAO 바인딩

    glGenBuffers(numVBOs, vbo); // VBO 생성 (numVBOs 사용)
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); // 첫 번째 VBO 바인딩 (정점 위치)
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexPositions), vertexPositions, GL_STATIC_DRAW); // 데이터 전송
}

void init(GLFWwindow* window) {
    // 셰이더 프로그램 생성 (utils:: 네임스페이스 사용)
    renderingProgram = utils::createShaderProgram("vertShader.glsl", "fragShader.glsl");
    if (renderingProgram == 0) { // 셰이더 프로그램 생성 실패 시 에러 처리
        std::cerr << "Failed to create shader program. Exiting." << std::endl;
        glfwTerminate();
        exit(EXIT_FAILURE);
    }

    // 카메라 및 큐브 위치 초기화
    cameraX = 0.0f; cameraY = 0.0f; cameraZ = 8.0f;
    cubeLocX = 0.0f; cubeLocY = -2.0f; cubeLocZ = 0.0f;

    setupVertices(); // 정점 데이터 설정 (VAO, VBO 생성 및 데이터 전송)

    // OpenGL 상태 설정 (초기화 시 한 번만 호출)
    glEnable(GL_DEPTH_TEST); // 깊이 테스트 활성화
    glDepthFunc(GL_LEQUAL); // 깊이 함수 설정 (GL_LESS보다 GL_LEQUAL이 더 일반적)

    // Uniform location은 셰이더 프로그램이 링크된 후 한 번만 가져오는 것이 효율적
    mvLoc = glGetUniformLocation(renderingProgram, "mv_matrix");
    pLoc = glGetUniformLocation(renderingProgram, "p_matrix");
    if (mvLoc == -1 || pLoc == -1) {
        std::cerr << "Warning: Could not find uniform locations for mv_matrix or p_matrix." << std::endl;
    }
}

void display(GLFWwindow* window, double currentTime) {
    // 매 프레임 시작 시 색상 버퍼와 깊이 버퍼를 지움
    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); // 두 버퍼 모두 지움
    glClearColor(0.0, 0.0, 0.0, 1.0); // 배경색을 검은색으로 설정 (이 함수 자체는 매번 호출할 필요는 없음)

    glUseProgram(renderingProgram); // 셰이더 프로그램 사용 시작

    // 매 프레임마다 화면 크기 가져오고 투영 행렬 재계산 (창 크기 변경에 대응)
    glfwGetFramebufferSize(window, &width, &height);
    aspect = (float)width / (float)height;
    pMat = glm::perspective(glm::radians(60.0f), aspect, 0.1f, 1000.0f);

    // 뷰 행렬 구축 (카메라 위치 기반)
    // glm::lookAt(eye, center, up) 함수를 사용하는 것이 더 일반적이고 유연합니다.
    vMat = glm::lookAt(glm::vec3(cameraX, cameraY, cameraZ), // 카메라 위치
        glm::vec3(0.0f, 0.0f, 0.0f),            // 카메라가 바라볼 지점 (여기서는 월드 원점)
        glm::vec3(0.0f, 1.0f, 0.0f));           // 카메라의 상향 벡터 (월드 Y축)

    // 모델 행렬 구축 (큐브 위치 및 애니메이션 기반)
    mMat = glm::translate(glm::mat4(1.0f), glm::vec3(cubeLocX, cubeLocY, cubeLocZ));
    // 큐브 회전 애니메이션 추가
    mMat = glm::rotate(mMat, glm::radians((float)currentTime * 50.0f), glm::vec3(0.0f, 1.0f, 0.0f)); // Y축 회전
    mMat = glm::rotate(mMat, glm::radians((float)currentTime * 30.0f), glm::vec3(1.0f, 0.0f, 0.0f)); // X축 회전

    // 모델-뷰 행렬 계산: V * M 순서 (주의: GLM은 열 우선(column-major)이므로 V * M)
    mvMat = vMat * mMat;

    // Uniform 변수에 행렬 데이터 전송
    // Uniform location은 init()에서 이미 가져왔으므로 재호출 필요 없음
    glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
    glUniformMatrix4fv(pLoc, 1, GL_FALSE, glm::value_ptr(pMat));

    // VAO 바인딩
    glBindVertexArray(vao[0]);

    // 정점 속성 활성화 및 VBO와 연결 (setupVertices에서 지정했지만, draw call 전에 다시 바인딩/활성화)
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); // VBO 0번을 다시 바인딩 (정점 위치 데이터)
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); // layout(location=0)과 연결
    glEnableVertexAttribArray(0); // 정점 속성 활성화

    // 큐브 그리기 (36개 정점 = 12개 삼각형)
    glDrawArrays(GL_TRIANGLES, 0, 36);

    // checkOpenGLError(); // 디버깅 시 유용
}

int main(void) {
    if (!glfwInit()) {
        std::cerr << "Failed to initialize GLFW" << std::endl;
        exit(EXIT_FAILURE);
    }
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // Core Profile 사용 명시
    glfwWindowHint(GLFW_SAMPLES, 4); // 안티앨리어싱을 위한 샘플 수 설정 (선택 사항)

    GLFWwindow* window = glfwCreateWindow(600, 600, "Chapter 4 - program 1", NULL, NULL);
    if (!window) {
        std::cerr << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        exit(EXIT_FAILURE);
    }

    glfwMakeContextCurrent(window);
    // GLEW 초기화는 GLFW 컨텍스트가 생성된 후에 이루어져야 합니다.
    if (glewInit() != GLEW_OK) {
        std::cerr << "Failed to initialize GLEW" << std::endl;
        glfwDestroyWindow(window);
        glfwTerminate();
        exit(EXIT_FAILURE);
    }
    glfwSwapInterval(1); // 수직 동기화 활성화

    init(window); // 초기화 함수 호출

    while (!glfwWindowShouldClose(window)) {
        display(window, glfwGetTime());
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    // 프로그램 종료 시 자원 해제
    glfwDestroyWindow(window);
    glfwTerminate();
    exit(EXIT_SUCCESS);
}

//vertShader.glsl
#version 430 core // core profile 사용 명시 (glfwHint와 일치)
layout (location=0) in vec3 position; // layout(location=0)으로 정점 위치 받음

uniform mat4 mv_matrix; // 모델-뷰 행렬
uniform mat4 p_matrix;  // 투영 행렬

void main(void) {
    // 최종 정점 위치 계산: p_matrix * mv_matrix * position
    // vec4(position, 1.0)을 사용하여 position을 동차 좌표로 변환
    gl_Position = p_matrix * mv_matrix * vec4(position, 1.0);
}

//fragShader.glsl
#version 430 core // core profile 사용 명시
out vec4 color; // 프래그먼트 셰이더 출력 색상

// 프래그먼트 셰이더에서는 mv_matrix와 p_matrix를 사용할 필요가 없습니다.
// uniform mat4 mv_matrix;
// uniform mat4 p_matrix; 

void main(void) {
    color = vec4(1.0, 0.0, 0.0, 1.0); // 빨간색 큐브 (알파값 1.0)
}
```



#### 3.1. 단계 1: 준비 (`setupVertices()` 함수 내부)

이 단계는 주로 CPU가 OpenGL 드라이버를 통해 GPU에게 렌더링에 필요한 자원(3D 모델의 데이터, 각종 설정)을 준비시키고 GPU 메모리(VRAM)에 업로드하는 과정이다.

1. **객체 ID 생성 요청:**
   - **코드:** `glGenVertexArrays(1, vao);` , `glGenBuffers(numVBOs, vbo);`
   - **CPU -> OpenGL 드라이버:** 애플리케이션(CPU)은 OpenGL 드라이버에게 VAO 객체와 VBO 객체를 생성하고 그 고유 ID를 반환해달라고 요청한다.
   - **OpenGL 드라이버 -> GPU:** 드라이버는 이 요청을 GPU가 이해할 수 있는 저수준 명령으로 변환하여 GPU에게 전달한다.
   - **GPU 내부:** GPU는 요청에 따라 내부적으로 고유 ID를 가진 VAO와 VBO를 위한 메타데이터 구조를 생성하고, 이 ID들을 드라이버를 통해 CPU의 `vao` 및 `vbo` 변수에 반환한다. **이 시점에는 아직 GPU 메모리(VRAM)에 실제 데이터가 복사되지 않는다. 단지 '데이터를 담을 수 있는 빈 그릇'만 만들어진 상태이다.**
2. **VAO 활성화 (정점 속성 설정 기록 준비):**
   - **코드:** `glBindVertexArray(vao[0]);`
   - **CPU -> OpenGL 드라이버:** CPU는 `vao[0]` VAO 객체를 현재 활성화된 VAO 바인딩 포인트에 연결하도록 명령한다.
   - **OpenGL 드라이버 -> GPU:** GPU 내부의 OpenGL 컨텍스트(현재 그래픽스 상태를 저장하는 메모리 영역)에서, **VAO 바인딩 포인트 레지스터의 값이 `vao[0]`의 고유 ID로 업데이트**된다. 이제 `vao[0]`는 '현재 활성화된 VAO'가 되며, 이후의 모든 정점 속성 설정들은 이 `vao[0]` 객체 안에 '캡슐화'되어 저장된다.
3. **VBO 활성화 및 정점 데이터 GPU로 업로드:**
   - **코드:** `glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);`
   - **CPU -> OpenGL 드라이버:** CPU는 `vbo[0]` VBO 객체를 `GL_ARRAY_BUFFER` 바인딩 포인트에 연결하도록 명령한다.
   - **OpenGL 드라이버 -> GPU:** `GL_ARRAY_BUFFER` 바인딩 포인트 레지스터의 값이 `vbo[0]`의 ID로 업데이트된다.
   - **코드:** `glBufferData(GL_ARRAY_BUFFER, sizeof(vertexPositions), vertexPositions, GL_STATIC_DRAW);`
   - **CPU -> OpenGL 드라이버:** CPU는 OpenGL 드라이버에게 CPU RAM에 있는 `vertexPositions` 배열의 데이터를 `GL_ARRAY_BUFFER` 바인딩 포인트에 연결된 `vbo[0]` 객체로 복사하여 GPU 메모리(VRAM)에 업로드하도록 명령한다. `GL_STATIC_DRAW` 힌트는 데이터가 자주 변경되지 않을 것임을 GPU에 알려 최적화에 도움을 준다.
   - **OpenGL 드라이버 -> GPU:** 드라이버는 `vertexPositions`가 저장된 CPU RAM의 주소에서 실제 데이터(바이트 스트림)를 읽어온다. 이 데이터는 PCIe(Peripheral Component Interconnect Express)와 같은 **고속 시스템 버스를 통해 GPU로 직접 전송된다.** GPU는 전송된 데이터를 받아서, `vbo[0]` 객체에 할당된 **VRAM 공간에 물리적으로 복사하여 저장한다.** **이 명령이 실행되는 순간, 큐브의 정점 데이터가 비로소 GPU 메모리에 존재하게 된다.**
4. **정점 속성 설정 기록 (VRAM의 데이터 사용 방식 정의):**
   - **코드:** `glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);`
   - **CPU -> OpenGL 드라이버:** CPU는 셰이더 프로그램의 `0`번 위치(`layout (location=0)`)에 해당하는 정점 속성이, 현재 `GL_ARRAY_BUFFER`에 연결된 `vbo[0]`의 데이터를 읽어올 때 '세 개의 float 값'씩 가져오고, 데이터 간의 간격(stride)이나 시작 오프셋이 어떻게 되는지 설정하도록 명령한다. 이 설정은 현재 활성화된 VAO(`vao[0]`)에 저장된다.
   - **OpenGL 드라이버 -> GPU:** GPU는 현재 바인딩된 VAO(`vao[0]`)의 내부 상태에, 0번 속성이 `vbo[0]`의 어떤 데이터를 어떤 형식으로 읽어야 하는지에 대한 **'메타 정보'(설정 데이터)를 기록한다.** **이 단계에서는 새로운 데이터가 VRAM으로 전송되지 않는다. 단지 이미 VRAM에 있는 VBO 데이터를 셰이더가 어떻게 해석하고 사용할지에 대한 '규칙'을 VAO에 저장하는 것이다.**
   - **코드:** `glEnableVertexAttribArray(0);`
   - **CPU -> OpenGL 드라이버:** CPU는 0번 정점 속성을 활성화하고, 이 활성화 여부도 `vao[0]`에 저장하도록 명령한다.
   - **OpenGL 드라이버 -> GPU:** GPU는 `vao[0]`의 내부 상태에 0번 정점 속성이 활성화되었다는 정보를 기록한다.



#### 3.2. 단계 2: 렌더링 (`display()` 함수 내부)



`setupVertices()` 함수가 완료된 후에도, `vao[0]`와 `vbo[0]`에 관련된 모든 데이터와 설정은 GPU 메모리 및 GPU의 OpenGL 컨텍스트 상태에 준비된 상태로 유지된다. `display()` 함수는 매 프레임마다 이 준비된 자원들을 활용하여 최종 화면을 그려낸다.

1. **셰이더 프로그램 사용 선언:**
   - **코드:** `glUseProgram(renderingProgram);`
   - **CPU -> OpenGL 드라이버:** CPU는 `renderingProgram`이라는 셰이더 프로그램을 GPU에 로드하고, 이제부터 모든 렌더링 작업에 이 셰이더를 사용하도록 준비하라고 명령한다.
   - **GPU 내부:** GPU는 해당 셰이더 프로그램의 컴파일된 코드를 자신의 셰이더 코어(Shader Core)에 로드하고 활성화한다. 이제 GPU의 렌더링 파이프라인은 이 셰이더 코드를 사용하여 정점 및 프래그먼트(픽셀 조각)를 처리할 준비가 된다.
2. **VAO 상태 복원:**
   - **코드:** `glBindVertexArray(vao[0]);`
   - **CPU -> OpenGL 드라이버:** CPU는 `vao[0]` VAO 객체를 다시 VAO 바인딩 포인트 레지스터에 연결하도록 명령한다.
   - **GPU 내부:** GPU는 `vao[0]` 객체 내부에 저장되어 있던 모든 정점 속성 관련 설정들(어떤 VBO를 써야 하는지, 각 속성별 데이터 형식, 활성화 여부 등)을 **모두 한 번에 현재 OpenGL 컨텍스트 상태로 복원한다.** **이것이 VAO를 사용하는 가장 큰 이유이다.** 복잡한 여러 설정들을 매번 다시 지정할 필요 없이, VAO 하나만 바인딩하면 모든 정점 관련 상태가 즉시 준비되는 효율적인 방식이다. 따라서 `display()` 함수 내에서 `glBindBuffer`, `glVertexAttribPointer`, `glEnableVertexAttribArray` 등을 다시 호출할 필요가 없어진다.
3. **Uniform 변수 전송:**
   - **코드:** `glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));`
   - **CPU -> OpenGL 드라이버:** CPU는 `mvMat`과 같은 CPU RAM에 있는 행렬 데이터를 읽어와, 현재 GPU에서 활성화된 셰이더 프로그램 내부의 `mvLoc` 위치에 해당하는 `uniform` 변수 메모리 공간에 넣어주도록 명령한다.
   - **OpenGL 드라이버 -> GPU:** `mvMat` 데이터가 시스템 버스를 통해 GPU로 전송되고, GPU는 이를 현재 활성화된 셰이더 프로그램 내부의 `uniform` 변수 공간에 복사해서 저장한다. 이 값들은 카메라 움직임이나 모델 변형 등에 따라 **프레임마다 변경될 수 있으므로, `display()` 함수에서 매 프레임 최신 값으로 업데이트하여 전송한다.**
4. **최종 그리기 명령 실행:**
   - **코드:** `glDrawArrays(GL_TRIANGLES, 0, 36);`
   - **CPU -> OpenGL 드라이버:** CPU는 최종 그리기 명령을 OpenGL 드라이버에 전달한다.
   - **GPU 내부:**
     - GPU는 현재 바인딩된 VAO(`vao[0]`)에 저장된 정보를 보고, 이 정보에 따라 `vbo[0]`에 접근하여 VRAM에 있는 36개의 정점 데이터를 순차적으로 읽어온다.
     - 읽어온 정점 데이터를 현재 활성화된 **버텍스 셰이더(Vertex Shader)**로 하나씩 입력한다.
     - 버텍스 셰이더는 이 정점 데이터를 가지고 연산(예: Model-View-Projection 행렬 곱셈을 통해 3D 공간의 정점을 2D 화면 좌표로 변환)을 수행하여 다음 렌더링 파이프라인 단계로 전달한다.
     - 이후 래스터화(Rasterization), **프래그먼트 셰이더(Fragment Shader)** 등의 복잡한 파이프라인 단계를 거쳐 최종적으로 화면에 표시될 픽셀들을 생성하고, 이를 백 버퍼(Back Buffer)라는 GPU 메모리 영역에 기록한다.
     - 마지막으로, 백 버퍼의 내용이 실제 화면으로 스왑(Swap)되면서 최종 3D 큐브 이미지가 사용자에게 표시된다.

이러한 모든 과정은 매우 빠른 속도로, 그리고 CPU와 GPU가 서로의 강점을 활용하여 협력적으로 이루어진다. CPU는 고수준의 명령과 논리를 제어하고, GPU는 복잡한 그래픽 계산을 병렬적으로 수행하여 효율성을 극대화한다. OpenGL은 바로 이 복잡한 GPU와의 통신을 추상화하여, C++ 코드로 3D 그래픽스를 효율적으로 제어할 수 있게 해주는 API(Application Programming Interface)이다.
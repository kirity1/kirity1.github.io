---
key:
title: '텍스처 매핑 이해'
excerpt: '그래픽스'
tags: [그래픽스]
---



### 3D 모델에 생명을 부여하는 방법: OpenGL 텍스처 매핑의 이해



본 문서는 3D 그래픽스 프로그래밍에서 오브젝트에 사실적인 질감을 부여하는 핵심 기법인 텍스처 매핑(Texture Mapping)에 대해 설명한다. 텍스처 매핑은 밋밋한 기하학적 모델에 다채로운 시각적 정보를 입히는 필수적인 과정이며, 그 원리와 구현 방식을 상세히 분석한다.

------



### 1. 텍스처 매핑의 필요성



3D 모델은 기본적으로 정점(Vertex)들의 집합과 이들을 연결하는 면(Face)들로 구성된 기하학적 구조물이다. 이러한 모델에 단색을 부여하는 것만으로는 복잡하고 현실적인 외형을 표현하기 어렵다. 예를 들어, 나무의 나이테, 벽돌 벽의 표면, 인물의 피부 질감 등은 단순한 색상으로는 구현하기 힘든 디테일을 요구한다. 텍스처 매핑은 이러한 문제를 해결하기 위해 도입된 기법으로, 2D 이미지(일반적으로 JPEG, PNG 등의 파일 형식)를 3D 모델의 표면에 적용하는 과정을 의미한다. 이때 사용되는 2D 이미지를 텍스처(Texture)라고 하며, 텍스처를 구성하는 각 픽셀 단위를 텍셀(Texel)이라 칭하여 화면에 렌더링되는 최종 픽셀과 구분한다.

------



### 2. 텍스처 좌표: 텍스처 매핑의 핵심 요소



텍스처 이미지가 3D 모델의 표면에 정확하게 적용되기 위해서는, 모델의 각 정점과 텍스처 이미지의 특정 위치 간의 상응 관계가 필요하다. 이 관계를 정의하는 것이 바로 **텍스처 좌표(Texture Coordinates)**이다. 3D 모델의 각 정점은 3차원 공간에서의 위치를 나타내는 (x, y, z) 좌표 외에, 텍스처 이미지 내의 위치를 지정하는 (s, t) 또는 (u, v) 형태의 2차원 좌표를 추가적으로 갖는다. **s (또는 u):** 텍스처 이미지의 가로 방향 좌표 (일반적으로 0.0에서 1.0 사이의 정규화된 값) **t (또는 v):** 텍스처 이미지의 세로 방향 좌표 (일반적으로 0.0에서 1.0 사이의 정규화된 값) 이 텍스처 좌표는 OpenGL 렌더링 파이프라인에 전달되어, 특정 3D 정점이 텍스처 이미지 내의 (s, t) 지점에 해당하는 텍셀의 색상 정보를 참조하도록 지시한다. 개발자가 모델의 각 정점에 텍스처 좌표를 어떻게 할당하느냐에 따라 텍스처 이미지가 모델 표면에 확장, 축소 또는 반복되어 나타나는 방식과 그 방향성이 결정된다. 이는 마치 재봉사가 옷감을 재단하듯이, 텍스처를 모델에 맞게 정밀하게 '설계'하는 과정에 해당한다.

------



### 3. OpenGL 렌더링 파이프라인에서의 텍스처 매핑 구현 과정



텍스처 매핑이 OpenGL 렌더링 파이프라인 내에서 어떻게 작동하는지 단계별로 상세히 설명한다.

**정점 데이터 및 텍스처 좌표 준비:** 3D 모델의 정점 위치(xyz)와 더불어, 각 정점에 할당될 텍스처 좌표(st 또는 uv)를 정의한다. 이러한 정점 관련 데이터는 **VBO(Vertex Buffer Object)**에 저장되어 GPU 메모리로 전송된다. 텍스처 좌표는 정점 위치와 동일한 VBO에 저장될 수도 있고, 별도의 VBO에 저장될 수도 있다. **VAO(Vertex Array Object)**는 이러한 VBO들이 셰이더의 특정 정점 속성(Vertex Attribute)에 어떻게 연결되는지에 대한 설정 정보(예: layout (location = 0)은 위치, layout (location = 1)은 텍스처 좌표)를 캡슐화한다. 즉, VAO에 정점 데이터와 텍스처 좌표 데이터의 연결 관계가 '붙여지는' 것이다.

**텍스처 이미지 로딩:** OpenGL은 이미지 파일(예: JPG, PNG)을 직접 처리할 수 없으므로, **SOIL2(Simple OpenGL Image Library 2)**와 같은 외부 이미지 로딩 라이브러리를 활용한다. SOIL2는 지정된 이미지 파일에서 픽셀 데이터를 읽어 들인 후, 이 데이터를 기반으로 OpenGL의 **텍스처 객체(Texture Object)**를 생성하고 GPU 메모리에 업로드한다. 이 텍스처 객체는 OpenGL 내에서 해당 텍스처를 고유하게 식별하는 정수 ID를 반환한다.

**텍스처 활성화 및 파라미터 설정:** `glBindTexture()` 함수를 사용하여 특정 텍스처 ID를 가진 텍스처 객체를 '현재 활성화된 텍스처'로 지정한다. 이후의 텍스처 관련 작업은 이 활성화된 텍스처에 적용된다. `glTexParameter()` 함수를 통해 활성화된 텍스처의 다양한 동작 방식을 설정한다. 주요 설정으로는 텍스처가 확대/축소될 때의 픽셀 처리 방식(**필터링**, 예: GL_LINEAR, GL_NEAREST), 그리고 텍스처 좌표가 0.0~1.0 범위를 벗어났을 때 텍스처를 어떻게 반복시킬지(**래핑 모드**, 예: GL_REPEAT, GL_CLAMP_TO_EDGE) 등이 있다.

**정점 셰이더(Vertex Shader) 처리:** 정점 셰이더는 VBO로부터 각 정점의 위치 정보와 함께 텍스처 좌표(`in vec2 texCoord;`)를 입력받는다. 정점 셰이더는 이 텍스처 좌표를 추가적인 처리 없이 다음 단계(프래그먼트 셰이더)로 전달하기 위해 `out vec2` 타입의 출력 변수에 할당한다.

**레스터라이저(Rasterizer)의 보간(Interpolation) 기능:** 정점 셰이더의 출력을 받은 레스터라이저는 3D 모델의 삼각형을 2D 화면의 픽셀(프래그먼트)로 변환하는 작업을 수행한다. 이 과정에서 레스터라이저는 단순히 정점의 위치뿐만 아니라, 정점에 할당된 모든 속성(텍스처 좌표, 법선 벡터, 색상 등)을 **선형적으로 보간(Interpolate)**한다. 즉, 3D 모델이 2D 화면의 픽셀 집합으로 변환될 때, 각 픽셀(프래그먼트)은 해당 픽셀의 화면상 위치에 비례하여 보간된 텍스처 좌표를 부여받는다. 이는 텍스처가 모델 표면에 끊김 없이 부드럽게 적용되도록 보장하는 핵심 메커니즘이다.

**프래그먼트 셰이더(Fragment Shader) 처리:** 레스터라이저로부터 보간된 텍스처 좌표를 입력받은 프래그먼트 셰이더는 해당 픽셀의 최종 색상을 결정한다. 프래그먼트 셰이더 내부에는 **`sampler2D`**라는 특별한 유니폼 변수가 선언되어 있다. 이 `sampler2D`는 CPU에서 `glBindTexture()`를 통해 바인딩된 실제 텍스처 이미지 객체를 참조하는 역할을 한다. 프래그먼트 셰이더는 `texture(sampler2D, interpolatedTexCoord)` 함수를 호출하여, 보간된 텍스처 좌표에 해당하는 텍셀의 색상 값을 텍스처 이미지로부터 **"샘플링(Sampling)"**한다. 샘플링된 이 색상 값이 해당 프래그먼트(픽셀)의 최종 출력 색상으로 할당되어 화면에 그려진다.

------



### 4. `glBindTexture()`와 `sampler`의 관계



많은 학습자들이 혼동하는 `glBindTexture()` 명령어와 셰이더의 `sampler` 변수는 서로 다른 단계에서 작동하며, 텍스처 사용을 위해 필수적으로 협력하는 관계이다.

**`glBindTexture()`**: 이 함수는 GPU 하드웨어에 대한 **물리적인 연결**을 설정한다. `glActiveTexture(GL_TEXTURE0)`로 0번 텍스처 유닛을 활성화한 후, `glBindTexture(GL_TEXTURE_2D, myTextureID)` 명령을 통해 **실제 텍스처 객체(데이터)**를 그 유닛에 할당한다. 이는 마치 CD 플레이어(텍스처 유닛)에 특정 CD(텍스처 객체)를 삽입하는 행위에 비유할 수 있다.

**`sampler`**: 이 변수는 셰이더 프로그램 내부에서 텍스처를 참조하기 위한 **논리적인 연결**이다. `uniform sampler2D myTextureSampler` 변수 자체는 데이터를 담고 있지 않다. 대신, CPU 코드의 `glUniform1i(textureLocation, 0)` 명령을 통해 텍스처 유닛의 번호(여기서는 0)를 전달받는다. 셰이더는 이 `sampler` 변수를 통해 **'0번 유닛에 연결된 텍스처'**를 사용하라고 지시받는 것이다.

결론적으로, `glBindTexture()`는 텍스처 유닛에 실제 데이터를 할당하는 **하드웨어적 명령**이고, `sampler`는 셰이더가 그 텍스처 유닛을 참조하기 위한 **논리적 변수**이다. 이 둘은 함께 작동해야만 텍스처 매핑이 완성된다.
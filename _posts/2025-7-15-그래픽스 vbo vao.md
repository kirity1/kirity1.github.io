---
key:
title: 'openGL vao와 vbo이해'
excerpt: '그래픽스'
tags: [그래픽스]
---

------

OpenGL에서 3D 모델을 화면에 렌더링하기 위해서는 모델의 각 **정점(Vertex)** 데이터를 GPU로 전송해야 한다. 이때, 정점의 위치, 색상, 법선 벡터, 텍스처 좌표 등 다양한 속성들이 활용된다. 이 데이터를 GPU로 효율적으로 전달하고, 셰이더에서 정확하게 수신하도록 하는 핵심 메커니즘 중 하나가 바로 **`layout (location=N)`** 퀄리파이어이다.



### `in` 변수와 `layout (location=N)`의 역할



셰이더 코드, 특히 **버텍스 셰이더(Vertex Shader)**를 분석하면 다음과 같은 코드 구문을 흔히 접할 수 있다.

OpenGL Shading Language

```
layout (location=0) in vec3 position;
layout (location=1) in vec3 normal;
layout (location=2) in vec2 texCoord;
```

여기서 **`in`**은 해당 변수가 셰이더의 **입력(Input)**임을 명시하며, **`vec3 position`**은 이 입력이 3차원 벡터 형태의 '위치' 데이터임을 의미한다. 핵심은 **`layout (location=N)`** 부분인데, 이는 이 `position` 변수가 **GPU 메모리 어딘가에 존재하는 'N'번 위치(slot)의 데이터 스트림을 수신할 것**이라고 셰이더가 자체적으로 선언하는 것이다.

이 'N'번 위치는 단순히 셰이더가 데이터를 받아들일 채널을 지정하는 논리적인 식별자로 작용한다.

------



### `particular buffer`의 실체: VBO



그렇다면 `layout (location=N)`이 참조하는 `particular buffer`는 정확히 무엇인가? 이는 바로 **VBO(Vertex Buffer Object)**를 지칭한다.

**VBO**는 정점 데이터(위치, 색상 등)를 GPU 메모리에 저장하기 위한 버퍼 객체이다. 개발자가 C++ 코드에서 `float` 배열에 정점 데이터를 정의하고 `glBufferData()`와 같은 함수를 사용하여 이 데이터를 GPU로 전송하면, 해당 데이터는 VBO에 저장된다. VBO는 본질적으로 원시적인 데이터의 '배열' 또는 '덩어리'이다.

------



### VAO를 통한 연결: 설정의 레시피



셰이더의 `layout (location=N)`과 VBO라는 데이터 덩어리를 논리적으로 연결해주는 매개체 역할을 하는 것이 바로 **VAO(Vertex Array Object)**이다.

VAO는 하나 이상의 VBO와 버텍스 셰이더의 `in` 변수들 간의 **연결 상태(binding state)**를 기억하는 객체이다. 즉, "어떤 VBO에서", "어떤 종류의 데이터(위치, 색상 등)를", "어떤 형식(float, int)", "어떤 크기(vec3, vec4)", "데이터 간 간격은 얼마로", "시작 오프셋은 어디부터" 등의 정보를 **`location=N`이라는 특정 슬롯에 매핑하여 VAO 내부에 저장**한다.

C++ 코드에서 이 연결 과정은 다음과 같이 수행된다:

1. **VBO에 데이터 저장**: `glGenBuffers()`, `glBindBuffer()`, `glBufferData()`를 사용하여 정점 데이터를 VBO에 업로드한다.
2. **VAO 생성 및 바인딩**: `glGenVertexArrays()`, `glBindVertexArray()`를 사용하여 VAO를 활성화한다.
3. **`layout location`과 VBO 데이터 연결**:
   - **`glEnableVertexAttribArray(N)`**: 'N'번 `location`에 해당하는 정점 속성을 활성화한다.
   - **`glVertexAttribPointer(N, ...)`**: 현재 바인딩된 VBO에서 'N'번 `location`으로 어떤 데이터를 어떻게 읽어올지 상세 설정을 VAO에 기록한다.

이렇게 설정이 완료되면, 이후에는 **`glBindVertexArray(myVAO);`** 한 줄만으로 이전에 저장했던 모든 설정(VBO, `layout location` 매핑, 데이터 형식 등)을 한 번에 불러올 수 있다.

------



### 정점 데이터의 자동화된 흐름



`glDrawArrays()`나 `glDrawElements()`와 같은 렌더링 호출이 발생하면, OpenGL은 현재 바인딩된 VAO에 저장된 설정을 바탕으로 VBO에서 정점 데이터를 자동으로 읽어와 셰이더로 전송한다.

- `layout (location=0) in vec3 position;`으로 선언된 셰이더의 `position` 변수는, 드로우 콜이 진행되는 동안 **VBO에서 첫 번째 정점의 위치 데이터, 두 번째 정점의 위치 데이터... 순서대로 매 호출마다 자동으로 수신하게 된다.**
- 이때 `location=0`은 VBO 내에서 어떤 특정 배열 인덱스 하나를 지칭하는 것이 아니다. 대신, VBO 안에 저장된 모든 정점들의 **'위치'라는 동일한 종류의 속성**이 셰이더의 0번 채널을 통해 흘러들어온다는 의미의 **논리적 식별자**이다.

결론적으로, `layout (location=N)`은 셰이더의 특정 `in` 변수가 **정점 속성(VBO에 저장된 데이터)의 한 종류(예: 위치, 색상)**를 받아들이는 **통로(채널)를 정의하는 식별자**이며, VAO가 이 통로와 실제 VBO의 데이터를 연결하는 역할을 수행한다. 이를 통해 각 정점은 개별적으로 자신의 데이터를 셰이더로 전달받아 처리될 수 있다.
---
key:
title: '링커와 모듈화 이해'
excerpt: '그래픽스'
tags: [그래픽스]
---

## C++ 모듈화의 비밀: `#include`와 컴파일-링크 과정으로 함수를 사용하는 방법



C++ 프로젝트를 개발하다 보면, 여러 개의 소스 파일(`*.cpp`)과 헤더 파일(`*.h` 또는 `*.hpp`)로 코드를 나누어 작성하는 것이 일반적이다. 예를 들어, `main.cpp` 파일에서 `utils.cpp` 파일에 정의된 `readShaderSource`, `createShaderProgram` 같은 함수들을 별다른 복잡한 설정 없이 단순히 `#include "utils.h"` 한 줄만 추가함으로써 사용할 수 있다.

이러한 편리함은 C++ 언어의 **컴파일(Compile)** 및 **링크(Link)** 과정이라는 핵심적인 동작 방식 덕분이다. 이 글에서는 그 원리를 자세히 설명한다.

------



### 1. 헤더 파일 (`.h` 또는 `.hpp`)의 역할



헤더 파일은 C++ 컴파일 과정에서 매우 중요한 역할을 수행한다. 이들은 주로 **선언(Declaration)**을 담고 있는 '사전' 또는 '설명서' 역할을 한다.

- **선언(Declaration)의 저장소:** 헤더 파일은 함수, 클래스, 변수 등의 **선언(declaration)**을 담고 있다. 여기서 선언이란 "이러한 이름과 타입을 가진 함수(또는 변수, 클래스)가 어딘가에 존재한다"고 컴파일러에게 미리 알려주는 역할을 한다. 하지만 선언에는 실제 코드 구현이나 데이터 정의가 포함되지 않는다.

  **예시:** `utils.h` 파일에 다음과 같은 줄이 있다고 가정한다.

  C++

  ```
  #ifndef UTILS_H
  #define UTILS_H
  
  #include <string>
  #include <GL/glew.h> // 또는 다른 필요한 헤더
  
  // 함수의 선언
  std::string readShaderSource(const char* filePath);
  GLuint createShaderProgram(const char* vsPath, const char* fsPath);
  
  #endif // UTILS_H
  ```

  `GLuint createShaderProgram(const char* vsPath, const char* fsPath);`와 같은 줄은 컴파일러에게 "createShaderProgram이라는 함수가 있고, 이 함수는 두 개의 `const char*` 인자를 받으며, `GLuint` 타입의 값을 반환한다"는 정보를 알려준다. 하지만 이 함수가 **정확히 어떻게 작동하는지에 대한 실제 코드(정의)**는 이 파일에 담겨 있지 않다.

- **컴파일러에게 정보 제공:** `main.cpp` 파일이 `#include "utils.h"`를 만나면, C++ **전처리기(Preprocessor)**는 `utils.h` 파일의 내용을 마치 `main.cpp` 파일의 해당 `#include` 지점에 그대로 **복사/붙여넣기** 한 것처럼 처리한다. 이렇게 되면 `main.cpp`를 컴파일할 때, `createShaderProgram()` 같은 함수를 호출하는 코드를 만나면, 컴파일러는 `utils.h`에서 미리 본 선언을 통해 "아, 이런 이름과 형태를 가진 함수가 어딘가에 있겠구나. 지금 당장은 코드가 없지만 나중에 링크할 때 찾아와서 연결해야지" 하고 에러 없이 컴파일을 진행할 수 있게 된다.

------



### 2. 소스 파일 (`.cpp`)의 역할



소스 파일은 헤더 파일에서 선언된 함수나 변수의 **실제 구현(정의)**을 담고 있는 파일이다.

- **정의(Definition)의 저장소:** 소스 파일은 함수, 클래스, 변수 등의 **정의(definition)**를 담고 있다. 정의는 실제 코드가 구현된 부분이다.

  **예시:** `utils.cpp` 파일에 다음과 같은 부분이 있다.

  C++

  ```
  #include "utils.h" // 관련 선언을 가져옴
  // 다른 필요한 헤더들
  
  // createShaderProgram 함수의 실제 구현 (정의)
  GLuint createShaderProgram(const char* vsPath, const char* fsPath) {
      // ... 셰이더 소스를 읽고, 컴파일하고, 링크하는 복잡한 코드 ...
      return programID;
  }
  
  // readShaderSource 함수의 실제 구현 (정의)
  std::string readShaderSource(const char* filePath) {
      // ... 파일에서 셰이더 소스를 읽는 코드 ...
      return shaderSource;
  }
  ```

  `GLuint createShaderProgram() { ... 함수의 실제 구현 코드 ... }`와 같은 부분이 이 함수의 실제 작동 방식과 논리를 담고 있는 **정의**이다.

- **개별 컴파일:** C++ 프로젝트는 일반적으로 여러 개의 `.cpp` 파일로 구성된다. 각 `.cpp` 파일은 다른 `.cpp` 파일과 독립적으로 컴파일된다.

  - `main.cpp`가 컴파일될 때, `createShaderProgram()` 함수가 실제로 어디에 정의되어 있는지는 알지 못한다. 단지 `utils.h`에서 선언만 봤기 때문에 "이 함수는 나중에 연결될 어딘가에 정의되어 있을 거야"라고만 생각한다. 컴파일러는 `main.cpp`를 컴파일하여 `main.obj`라는 **오브젝트 파일(Object File)**을 생성한다.
  - `utils.cpp`도 자체적으로 컴파일된다. 이때 `createShaderProgram()` 함수의 실제 정의를 포함하고 있으므로, 이 함수가 실제로 어떻게 작동하는지에 대한 **머신 코드(기계어 코드)**를 담은 `utils.obj`라는 **오브젝트 파일**을 생성한다.

  각 `.obj` 파일은 컴파일된 바이너리 코드 조각이지만, 아직 완전한 실행 파일은 아니다. 특히, 다른 `.obj` 파일에 정의된 함수를 호출하는 부분에는 해당 함수의 실제 메모리 주소가 아닌, '이름'으로만 참조 정보가 남아있다.

------



### 3. 링커(Linker)의 역할: "잃어버린 조각을 찾아서 합치기"



이 단계가 여러 소스 파일을 하나로 합쳐서 실행 가능한 프로그램을 만드는 데 있어 가장 핵심적인 부분이다.

- **오브젝트 파일 연결:** 컴파일러가 각 `.cpp` 파일을 컴파일하여 생성한 여러 개의 `.obj` 파일들(예: `main.obj`, `utils.obj`)은 아직 완벽한 실행 파일이 아니다. 이 `.obj` 파일들은 서로 다른 `.cpp` 파일에 정의된 함수를 호출하는 부분에서 "이 함수는 나중에 어딘가에서 찾아와서 연결해야 해"라는 '외부 참조(External Reference)'만을 가지고 있다.
- **링커의 작업:** **링커(Linker)**는 컴파일러가 생성한 이 모든 `.obj` 파일들(그리고 필요한 경우 미리 컴파일된 라이브러리 파일들)을 가져와서, 각 파일이 가지고 있는 '외부 참조'를 실제 '정의'와 연결하는 작업을 수행한다.
  - 예를 들어, `main.obj`가 `createShaderProgram()` 함수를 호출하는 코드를 가지고 있다면, 링커는 `utils.obj` 파일 안에 있는 `createShaderProgram()`의 실제 정의(기계어 코드)를 찾아와서 `main.obj`의 호출 부분을 이 실제 코드로 연결한다. 즉, `main.obj`의 "여기 `createShaderProgram` 함수를 호출해야 해"라는 '약속'을 `utils.obj`에 있는 `createShaderProgram` 함수의 실제 시작 주소로 '교체'한다.
- **최종 실행 파일 생성:** 이 링킹 과정을 통해 모든 외부 참조들이 해결되고, 서로 다른 `.obj` 파일들의 코드 조각들이 합쳐져 하나의 완전한 **실행 파일(`*.exe` 또는 `a.out` 등)**이 생성된다. 이 실행 파일은 이제 운영체제에서 직접 로드하고 실행할 수 있는 형태가 된다.

------



### 요약:



- **`#include "utils.h"`:** `main.cpp`를 컴파일할 때, `createShaderProgram` 같은 함수가 존재한다고 컴파일러에게 미리 알려주어, 실제 코드가 없어도 컴파일 오류가 발생하지 않게 한다. 이는 **'선언'**을 공유하는 과정이다.
- **`utils.cpp`:** `createShaderProgram` 함수의 **실제 코드(정의)**를 포함하고 있으며, 독립적으로 컴파일되어 `utils.obj` 파일을 생성한다.
- **링커:** `main.obj` 파일이 `createShaderProgram` 함수를 "호출"하는 부분을, `utils.obj` 파일이 가지고 있는 `createShaderProgram`의 "실제 코드"와 연결하여 최종 실행 파일을 만든다.

따라서 개발자가 `#include` 지시어를 추가하고 컴파일 환경에서 `main.cpp`와 `utils.cpp` (또는 해당 `.obj` 파일들)을 함께 링커에게 넘겨주면, C++ 프로젝트는 문제없이 빌드되고 실행될 수 있다. 이것이 C++의 모듈화된 프로그래밍과 컴파일-링크 시스템의 기본 원리이다.
---
key:
title: 'openGL 화면 매트릭스 설정과 c++ 변수 초기화 위치 에러'
excerpt: '그래픽스'
tags: [그래픽스]
---

### OpenGL 카메라 제어: C++ 변수 초기화와 3D 렌더링 원리



OpenGL 렌더링 파이프라인에서 3D 모델을 화면에 그리기 위해서는 정확한 카메라 제어가 필수적이다. 초기 단계에서는 `glm::translate` 함수를 이용하여 카메라의 위치만을 조정하여 뷰 매트릭스를 설정하는 경우가 많다.

C++

```
vMat = glm::translate(glm::mat4(1.0f), cameraC);
```

이 방식은 카메라가 월드의 Z축 음수 방향을 고정적으로 바라보는 단순한 상황에서는 작동하지만, 카메라의 방향을 바꾸거나 특정 지점을 바라보도록 제어하는 데는 한계가 따른다. 이때 **카메라의 위치(Position)와 방향(Orientation)을 모두 반영하는 뷰 매트릭스**를 직접 구성하는 방식이 요구된다.

------



#### 카메라 움직임의 원리: 월드 변환의 역



3D 렌더링에서 카메라를 "움직인다"는 개념은 실제로는 **장면(Scene) 내의 모든 오브젝트를 카메라의 움직임과 반대 방향으로 이동시키고 회전시키는 것**을 의미한다. 이는 사용자가 카메라를 조작할 때 마치 주변 세상이 자신에게 다가오거나 멀어지는 것처럼 느끼는 착시 현상과 유사하다. 이러한 원리가 **뷰 매트릭스(View Matrix)**의 핵심이다.

따라서 '카메라를 앞으로 이동시킨다'는 것은 월드 좌표계의 고정된 '앞'을 기준으로 하는 것이 아니라, **카메라가 현재 바라보고 있는 방향(카메라의 N 벡터)**을 기준으로 그 방향으로 전진하는 것을 의미한다.

------



#### C++ 전역 변수 초기화 규칙과 `R_matrix` 문제



OpenGL 뷰 매트릭스 구현 중 회전을 담당하는 `R_matrix`를 구성하는 과정에서 C++ 전역 변수 초기화와 관련된 문제가 발생할 수 있다. 예를 들어, `R_matrix`의 각 요소를 전역 스코프에서 직접 할당하려 할 때 다음과 같은 오류가 발생할 수 있다.

C++

```
glm::mat4 R_matrix(1.0f); // 전역 변수 선언

// 이 코드들은 함수 내부에서 실행되어야 한다.
R_matrix[0][0] = cameraU.x; // "이 선언에는 스토리지 클래스 또는 형식 지정자가 없습니다" 오류 발생 가능성
// ... (나머지 요소 할당)
```

`glm::vec3` 변수를 선언할 때, 그 초기화 인자에 `const`가 아닌 일반 변수를 사용하는 경우에도 **"집계 개체에는 `{...}를 사용한 초기화가 필요합니다"**와 같은 오류가 발생할 수 있다.

이러한 오류들은 모두 **C++ 언어의 전역 변수 초기화 규칙**에 기인한다. C++에서 함수 외부, 즉 **전역 스코프**는 변수를 **선언하고 정적인 값으로 초기화**하는 영역이다. 여기서는 컴파일러가 값을 미리 알 수 있는 리터럴(예: `1.0f`)이나 `const` 키워드로 선언된 변수만을 사용하여 초기화가 가능하다. `const` 변수는 컴파일러에게 값이 변경되지 않음을 보장하여 **컴파일 시간**에 해당 값을 확정할 수 있도록 한다.

반면, `R_matrix[0][0] = cameraU.x;`와 같이 변수의 특정 메모리 위치에 값을 '할당'하는 연산은 CPU가 실제로 명령을 수행해야 하는 **런타임 동작**이다. 컴파일러는 함수 외부에서 이러한 '실행 가능한 명령'을 마주하면, 이를 유효한 변수 선언이나 타입 지정으로 인식하지 못하고 오류를 발생시키는 것이다.

------



#### 컴파일 시간 vs. 런타임: C++의 근본적 구분



이 문제를 통해 C++의 컴파일 시간과 런타임의 근본적인 차이를 이해하는 것이 중요하다.

- **컴파일 시간 (Compile Time):** 소스 코드를 기계어 코드로 번역하는 단계이다. 이때 컴파일러는 코드의 문법, 변수 타입 등을 검사하고, **정적으로 값이 확정될 수 있는 변수들을 초기화**한다. 예를 들어, `glm::vec3 cameraU(1.0f, 0.0f, 0.0f);`와 같이 리터럴 상수나 `const` 변수를 사용하는 초기화는 컴파일러가 미리 메모리에 해당 값을 배치할 수 있어 컴파일 시간에 처리된다. 이는 복잡한 계산이나 동적 결정이 필요 없는 '정적인 정보'에 해당한다.
- **런타임 (Run Time):** 컴파일된 기계어 코드가 CPU에 의해 실제로 실행되는 단계이다. 변수에 값을 할당하거나, 함수를 호출하거나, 조건문/반복문을 실행하는 등 **동적인 동작이나 계산**이 이루어진다. `R_matrix`의 각 요소를 `cameraU.x`와 같은 다른 변수의 값으로 할당하는 것은 런타임에 CPU가 해당 값을 읽어와 특정 메모리 위치에 기록해야 하는 명백한 '동작'이다. 전역 스코프는 이러한 런타임 동작을 수행하는 영역이 아니므로, 컴파일러가 이를 받아들이지 않는 것이다.

------



#### 해결 방안: 런타임 연산은 함수 내부에서



이 문제의 해결책은 `R_matrix`를 구성하고 각 요소에 값을 할당하는 모든 코드를 **`display()` 함수 내부**로 이동시키는 것이다. `display()` 함수는 일반적으로 매 프레임마다 호출되므로, 뷰 매트릭스를 항상 최신 상태로 업데이트하기에 적합한 위치이다.

C++

```
void display(GLFWwindow* window, double currentTime) {
    // ... (생략)

    // 1. T_matrix (이동 행렬) 생성
    // 카메라 위치의 음수 값으로 이동하여 오브젝트들을 카메라 반대 방향으로 이동시킨다.
    glm::mat4 T_matrix = glm::translate(glm::mat4(1.0f), -cameraC); 

    // 2. R_matrix (회전 행렬) 생성 - 이제 함수 내부에서 안전하게 할당한다.
    glm::mat4 R_matrix(1.0f); 
    R_matrix[0][0] = cameraU.x;
    R_matrix[0][1] = cameraU.y;
    R_matrix[0][2] = cameraU.z;
    R_matrix[0][3] = 0.0f;

    R_matrix[1][0] = cameraV.x;
    R_matrix[1][1] = cameraV.y;
    R_matrix[1][2] = cameraV.z;
    R_matrix[1][3] = 0.0f;

    R_matrix[2][0] = -cameraN.x; 
    R_matrix[2][1] = -cameraN.y;
    R_matrix[2][2] = -cameraN.z;
    R_matrix[2][3] = 0.0f;

    R_matrix[3][0] = 0.0f;
    R_matrix[3][1] = 0.0f;
    R_matrix[3][2] = 0.0f;
    R_matrix[3][3] = 1.0f;

    // 3. 최종 뷰 행렬 V 계산: R 행렬과 T 행렬을 R * T 순서로 곱한다.
    vMat = R_matrix * T_matrix;

    // ... (나머지 렌더링 코드)
}
```

------



### 결론



이 경험을 통해 C++의 전역 변수 초기화 규칙, 컴파일 시간과 런타임의 명확한 구분, 그리고 `glm` 라이브러리를 활용한 뷰 매트릭스 구성의 실질적인 원리를 이해할 수 있었다. 특히, 카메라의 움직임이 씬 내의 오브젝트를 변환하는 '착시'라는 개념과, 이를 위해 **카메라의 위치와 방향(U, V, N 벡터)**을 모두 고려하는 복잡한 뷰 매트릭스가 어떻게 구성되는지 파악하는 것은 3D 그래픽스 프로그래밍의 핵심 개념을 정립하는 데 기여했다. 향후 과제는 이러한 U, V, N 벡터를 카메라의 위치 및 바라보는 지점에서 실제 계산해내는 방법을 구현하는 것이다.
---
key:
title: 'vertexArray와 indices, 인덱싱기법을 통해서 draw를 최적화하는 방법'
excerpt: '그래픽스'
tags: [그래픽스]
---

OpenGL 성능 최적화를 위한 핵심 원리: 인덱스 버퍼링과 GPU의 작동 방식

### **1. 문제의 정의: 정점 데이터의 중복성**



가장 기본적인 3차원 객체인 정육면체(cube)를 예로 들어 데이터 중복 문제를 설명할 수 있다. 기하학적으로 정육면체는 8개의 고유한 정점(vertex)으로 정의된다. 그러나 OpenGL과 같은 래스터화(rasterization) 기반의 렌더링 파이프라인은 삼각형을 기본 단위(primitive)로 사용하므로, 객체를 삼각형의 집합으로 표현해야 한다.

- 정육면체는 6개의 사각형 면으로 구성된다.
- 각 사각형 면은 2개의 삼각형으로 분할될 수 있다.
- 각 삼각형은 3개의 정점을 필요로 한다.

결론적으로, 하나의 정육면체를 렌더링하기 위해서는 총 `6면 × 2삼각형/면 × 3정점/삼각형 = 36`개의 정점이 정의되어야 한다. 8개의 고유한 정점만으로 기하학적 형태가 결정됨에도 불구하고, 렌더링을 위해서는 36개의 정점 데이터가 요구되는 것이다. 이는 하나의 정점이 최소 3개 이상의 면에 의해 공유되기 때문에 발생하는 현상으로, 해당 정점의 속성 데이터(위치, 색상, 법선 벡터 등)가 메모리상에 여러 번 중복되어 저장되는 결과를 초래한다.



이러한 데이터의 중복성은 VBO(Vertex Buffer Object)의 크기를 증가시켜 VRAM의 비효율적인 사용을 야기하며, CPU와 GPU 간의 데이터 전송 대역폭을 불필요하게 점유하여 시스템 전체의 성능 저하를 유발하는 주요 원인이 된다.

------



### **2. 해결 방안: 데이터와 인덱스의 분리**



이러한 비효율을 해결하기 위해, OpenGL은 데이터를 두 가지의 논리적 집합으로 분리하여 관리하는 방식을 채택한다.

- **정점 배열 (Vertex Array):** 렌더링 될 객체를 구성하는 **고유한 정점 데이터의 집합**이다. 이는 VBO에 저장될 원본 데이터에 해당하며, 각 정점의 위치, 색상, 법선 벡터 등 상대적으로 큰 크기의 부동소수점 데이터로 구성된다. 정육면체의 경우, 8개의 고유한 정점 정보가 이 배열에 속한다.
- **인덱스 배열 (Index Array):** 정점 배열에 정의된 정점들을 특정 순서에 따라 연결하여 기하학적 형상(주로 삼각형)을 구성하는 방법을 명시하는 **순서 정보의 집합**이다. 이 데이터는 용량이 작은 정수(integer) 값들로 구성되며, EBO(Element Buffer Object)에 저장된다. 정육면체의 경우, 36개의 정수 값이 삼각형을 구성하기 위한 순서를 정의한다.

이와 같이 '실질적 데이터'와 '데이터의 참조 순서'를 분리함으로써, 큰 용량의 정점 데이터를 메모리에 단 한 번만 저장하고, 작은 용량의 인덱스 값만을 재사용하여 데이터의 중복성을 근본적으로 제거하고 메모리 효율성을 극대화할 수 있다.

------



### **3. 렌더링 전략 비교: CPU 기반 처리와 GPU 기반 처리**



인덱스 배열을 활용하더라도, 이를 처리하여 최종 이미지를 생성하는 방식에 따라 시스템의 효율성은 크게 달라질 수 있다.



#### **3.1. 비효율적 접근: CPU에서의 데이터 재구성 (`glDrawArrays`)**



이 방식은 GPU에 데이터를 전달하기 전, CPU가 인덱스 배열을 해석하여 완전한 형태의 중복 정점 배열을 미리 생성하는 과정에 기반한다.

- **데이터 흐름:**

  1. **CPU (데이터 준비):** 고유 정점 배열(`vertices`)과 인덱스 배열(`indices`)을 생성한다. 이후, 인덱스 배열의 크기만큼 반복문을 실행하여, 인덱스 배열의 값을 참조해 고유 정점 배열로부터 해당하는 정점 데이터를 조회하고, 이를 새로운 배열(`pvalues`)에 순차적으로 복사한다. 이 과정을 통해 생성된 `pvalues` 배열은 렌더링에 필요한 모든 정점 데이터를 
  2. 1. 중복하여 포함하는 거대한 배열이 된다.
     2. **데이터 전송 (CPU → GPU):** `glBufferData` 함수를 통해 중복 데이터로 구성된 `pvalues` 배열 전체를 VBO에 업로드한다. 이 단계에서 불필요한 데이터 전송이 발생하여 시스템 버스 대역폭을 점유하고 VRAM을 비효율적으로 사용하게 된다.
     3. **GPU (그리기 명령):** `glDrawArrays` 함수가 호출되면, GPU는 VBO에 저장된 정점 데이터를 처음부터 끝까지 순차적으로 처리한다. 이 과정에서 GPU는 각 정점의 공유 여부를 인지하지 못하며, 단순히 선형적인 데이터 스트림으로 간주하여 연산을 수행한다.

  이 접근법은 GPU가 제공하는 인덱싱 관련 하드웨어 가속 기능을 활용하지 않으므로 근본적인 비효율성을 내포한다.

  

  #### **3.2. 효율적 접근: GPU로의 작업 위임 (`glDrawElements`)**

  

  이 방식은 데이터의 준비와 실제 렌더링 과정을 분리하여, 각각의 처리를 가장 효율적으로 수행할 수 있는 프로세서에 위임하는 전략을 취한다.

  - **데이터 흐름:**
    1. **CPU (데이터 준비):** 고유 정점 배열(`vertices`)과 인덱스 배열(`indices`)만을 생성한다. CPU 레벨에서의 데이터 재구성 과정은 완전히 생략된다.
    2. **데이터 전송 (CPU → GPU):**
       - **VBO (Vertex Buffer Object):** `glBindBuffer(GL_ARRAY_BUFFER, ...)`와 `glBufferData(...)`를 사용하여 고유 정점 배열(`vertices`)을 VBO에 업로드한다.
       - **EBO (Element Buffer Object):** `glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ...)`와 `glBufferData(...)`를 사용하여 인덱스 배열(`indices`)을 인덱스 데이터 전용 버퍼인 EBO에 업로드한다.
    3. **GPU (그리기 명령):** `glDrawElements` 함수가 호출되면, GPU는 EBO에 저장된 인덱스를 순차적으로 읽어들인다. 그리고 해당 인덱스가 가리키는 VBO 내의 정점 데이터를 참조하여 렌더링 파이프라인을 실행한다.

  이 방식은 데이터 전송량을 최소화하고 CPU의 부담을 줄이며, GPU가 하드웨어적으로 최적화된 방식으로 작업을 처리하도록 유도하는 현대적인 그래픽스 프로그래밍의 표준적 접근법이다.

  ------

  

  ### **4. GPU 내부의 최적화 메커니즘: 정점 캐시 (Vertex Cache)**

  

  `glDrawElements` 호출 시 GPU가 높은 효율성을 보이는 근본적인 이유는 **정점 캐시(Vertex Cache)**라는 하드웨어 구성요소에 있다. GPU는 작업을 생략하는 것이 아니라, 데이터 접근을 가속화하여 효율을 높인다.

  1. GPU는 EBO로부터 처리할 정점의 인덱스(예: 42)를 수신한다.
  2. GPU는 우선적으로 자신의 고속 내부 메모리인 **정점 캐시**에서 해당 인덱스의 처리된 정점 데이터가 존재하는지 확인한다.
  3. **캐시 미스 (Cache Miss):** 캐시에 해당 데이터가 존재하지 않을 경우, GPU는 상대적으로 접근 속도가 느린 VRAM에서 정점 데이터를 인출(fetch)한다. 인출된 데이터는 버텍스 셰이더 등의 파이프라인 단계를 거쳐 처리된 후, 그 결과가 정점 캐시에 저장된다.
  4. **캐시 히트 (Cache Hit):** 이후 다른 삼각형을 구성하기 위해 동일한 인덱스(42)를 다시 수신하면, GPU는 VRAM에 접근할 필요 없이 정점 캐시에 저장된 데이터를 즉시 재사용한다. 이 과정은 VRAM 접근에 비해 훨씬 빠른 속도로 이루어진다.

  이처럼 GPU의 렌더링 효율성은 **작업의 생략**이 아닌, **데이터 접근의 지역성(locality of reference)을 활용한 고속 데이터 재사용**에 기인한다.

  ------

  

  ### **5. 결론: CPU와 GPU의 역할 분담**

  

  효율적인 3D 렌더링 파이프라인은 CPU와 GPU 간의 명확한 역할 분담을 통해 완성된다.

  - **CPU**는 프로그램의 전체적인 논리 흐름을 제어하고, 렌더링에 필요한 최소한의 데이터, 즉 고유 정점 데이터와 인덱스 데이터를 준비하여 GPU에 전송하는 역할을 담당한다.
  - **GPU**는 전달받은 데이터를 기반으로, 수천 개의 연산 코어를 활용하여 복잡한 그래픽스 연산을 병렬적으로 처리하는 데 특화되어 있다.

  CPU 단계에서 데이터를 미리 재구성하는 것은 GPU의 전문화된 처리 능력을 활용하지 못하는 비효율적인 접근이다. **인덱스 데이터를 EBO에 담아 `glDrawElements` 함수로 렌더링을 위임**하는 것은, 각 프로세서가 자신의 아키텍처에 가장 적합한 작업을 수행하도록 하는 최적화의 핵심 원리라 할 수 있다

### **6. 2단계 최적화 요약**



결론적으로, 인덱스 버퍼링을 활용한 고성능 렌더링은 다음과 같은 2단계의 명확한 최적화 과정으로 요약될 수 있다. 각 단계는 서로 다른 시스템 자원을 대상으로 하며, 상호 보완적으로 작용하여 전체 렌더링 파이프라인의 효율을 극대화한다.



#### **6.1. 1단계 최적화: 데이터 생성의 효율화 (CPU & RAM)**



첫 번째 최적화는 데이터가 생성되는 **CPU와 시스템 메모리(RAM)** 단계에서 이루어진다. 이는 '무엇을, 얼마나 많이 만들 것인가'의 문제에 초점을 맞춘다.

- **핵심 기술:** 고유 정점 데이터와 인덱스 데이터의 분리.
- **목표:** 렌더링에 필요한 데이터의 총량 자체를 감소시키는 것.
- **효과:** 무거운 부동소수점 기반의 정점 데이터를 중복으로 계산하거나 저장할 필요가 없어지므로, **CPU의 연산 부하가 감소**하고 **시스템 메모리의 사용량이 절감**된다. 이는 애플리케이션의 전반적인 반응성과 안정성에 기여한다.

이러한 최적화의 근간에는 **'참조(reference)'** 의 원리가 있다. 인덱스 배열에 저장되는 값은 `(x, y, z)` 좌표 자체가 아닌, 단순히 그 좌표가 저장된 정점 배열의 위치를 가리키는 **정수 '번호표'** 이다. 예를 들어, 인덱스 배열에 `42`라는 값이 있다면, 이는 정점 배열의 42번째 위치에 있는 실제 `(x, y, z)` 데이터를 참조하라는 의미이다. 이처럼 무거운 실제 데이터는 한 번만 저장하고 가벼운 '번호표'만 재사용함으로써 데이터의 총량을 획기적으로 줄이는 것이 이 단계 최적화의 핵심이다.



#### **6.2. 2단계 최적화: 데이터 렌더링의 가속 (GPU & VRAM)**



두 번째 최적화는 생성된 데이터가 처리되는 **GPU와 그래픽 메모리(VRAM)** 단계에서 이루어진다. 이는 '준비된 데이터를 어떻게 사용할 것인가'의 문제에 집중한다.

- **핵심 기술:** EBO와 `glDrawElements`를 통한 GPU 정점 캐시의 활용.
- **목표:** GPU가 정점 데이터에 접근하는 속도를 가속하는 것.
- **효과:** GPU는 VRAM에서 동일한 정점 데이터를 반복적으로 인출하는 대신, 고속의 정점 캐시에서 데이터를 즉시 재사용한다. 이를 통해 VRAM 접근 병목 현상을 최소화하고, 셰이더 연산에 더 많은 자원을 할당할 수 있어 **실질적인 렌더링 속도가 향상**된다.

이 과정 역시 **'참조'** 원리를 기반으로 동작한다. `glDrawElements` 명령이 호출되면, GPU는 EBO에 저장된 '번호표(인덱스)'를 순차적으로 읽는다. 그리고 해당 '번호표'를 주소 삼아 VBO에서 실제 `(x, y, z)` 데이터를 참조하여 가져온다. 이때 **정점 캐시**는 이 참조 과정을 가속한다. GPU가 특정 '번호표'(예: `42`)에 해당하는 데이터를 한 번 참조하여 처리했다면, 그 결과를 캐시에 저장해 둔다. 이후 동일한 '번호표' `42`가 다시 등장했을 때, GPU는 VRAM까지 다시 찾아갈 필요 없이 캐시에서 직접 데이터를 가져와 사용함으로써 렌더링 과정을 극적으로 가속할 수 있다.

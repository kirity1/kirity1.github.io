---
key:
title: 'openGL 컨텍스트 가볍게 알기'
excerpt: '그래픽스'
tags: [그래픽스]
---

GLFW: 윈도우 생성과 OpenGL 컨텍스트 활성화의 중요성



OpenGL 기반 그래픽스 애플리케이션 개발 시, 화면에 시각적 요소를 렌더링하기 위해 필수적인 단계가 존재한다. 그 중 하나가 **렌더링 컨텍스트(Rendering Context)** 개념이다. OpenGL은 이 컨텍스트를 통해 GPU에 작업을 명령한다.

GLFW(Graphics Library Framework)는 OpenGL 애플리케이션을 위한 윈도우, 입력, 컨텍스트 등을 관리하는 경량 라이브러리이다. GLFW를 사용하여 윈도우를 생성할 때, 개발자들이 종종 혼동하는 지점은 "윈도우 생성만으로 OpenGL 컨텍스트가 자동으로 활성화되지 않는다"는 사실이다.

------



#### 1. `glfwCreateWindow()`: 윈도우 생성



`glfwCreateWindow()` 함수는 화면에 표시될 **윈도우(Window)** 객체를 생성하는 역할을 수행한다.

C++

```
GLFWwindow* window = glfwCreateWindow(600, 600, "Chapter2 - program1", NULL, NULL);
```

이 코드는 600x600 크기의 "Chapter2 - program1"이라는 제목을 가진 윈도우를 생성한다. 그러나 이 윈도우는 아직 **OpenGL 명령을 수신할 준비가 되어 있지 않다.** 윈도우는 단순한 '프레임'에 불과하며, 이 프레임 내부에 OpenGL이 그림을 그릴 수 있는 '캔버스'를 연결해야 한다. 이 '캔버스' 역할을 담당하는 것이 바로 **OpenGL 컨텍스트**이다.

윈도우는 여러 개 생성될 수 있으며, 각 윈도우는 고유한 OpenGL 컨텍스트를 가질 수 있다.

------



#### 2. `glfwMakeContextCurrent()`: OpenGL 컨텍스트 활성화



이 지점에서 **`glfwMakeContextCurrent()`** 함수의 중요성이 부각된다.

C++

```
glfwMakeContextCurrent(window);
```

이 함수는 `glfwCreateWindow()`를 통해 생성된 **특정 윈도우(`window`)에 대한 OpenGL 컨텍스트를 현재 스레드의 활성 컨텍스트로 설정**한다. 즉, 이 함수 호출 이후부터 해당 스레드에서 발생하는 모든 OpenGL 호출(예: `glClearColor`, `glClear`, `glUseProgram` 등)은 이 윈도우의 컨텍스트에 연결되어 작동하게 된다.

**이 과정이 필요한 이유:**

- **다중 컨텍스트 지원:** GLFW는 여러 윈도우와 각각의 OpenGL 컨텍스트를 지원한다. 특정 스레드에서 어떤 윈도우에 렌더링할 것인지 명시적으로 지정하기 위해 `glfwMakeContextCurrent()`가 요구된다.
- **스레드별 컨텍스트:** OpenGL 컨텍스트는 스레드별로 관리된다. 따라서 OpenGL 명령을 발행하는 스레드는 반드시 활성 컨텍스트를 보유해야 한다.
- **자원 관리:** 컨텍스트가 활성화되어야 GLEW와 같은 확장 라이브러리들이 OpenGL 드라이버로부터 필요한 함수 포인터를 올바르게 획득할 수 있다.

코드에서 `glfwMakeContextCurrent(window);` 다음에 `glewInit();`이 호출되는 이유도 여기에 있다. GLEW는 활성화된 OpenGL 컨텍스트를 통해 드라이버 정보를 얻어와야 하기 때문이다.

------



#### 3. `glewInit()`: OpenGL 확장 로딩



OpenGL은 지속적으로 발전하는 API로서, 새로운 기능(확장)들이 꾸준히 추가된다. 그러나 모든 드라이버가 항상 최신 버전을 완벽하게 지원하는 것은 아니다. **GLEW(OpenGL Extension Wrangler Library)**는 이러한 확장들을 용이하게 사용할 수 있도록 지원하는 라이브러리이다.

C++

```
if (glewInit() != GLEW_OK) { exit(EXIT_FAILURE); }
```

`glewInit()` 함수는 현재 활성화된 OpenGL 컨텍스트를 검사하고, 해당 컨텍스트에서 지원하는 모든 OpenGL 함수 포인터(확장 함수 포함)를 로딩한다. 이 과정이 성공적으로 이루어져야 셰이더 프로그래밍이나 VBO(Vertex Buffer Object)와 같은 최신 OpenGL 기능을 활용할 수 있다. **반드시 `glfwMakeContextCurrent()` 호출 이후에 `glewInit()`을 호출해야 한다.**

------